<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schatzoeken: Klas vs AI - Reinforcement Learning Les</title>
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #10b981;
            --accent: #f59e0b;
            --danger: #ef4444;
            --grid-size: 7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #1f2937;
        }

        .header {
            background: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 3em;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .score-bar {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 30px;
            align-items: center;
            max-width: 1200px;
            margin: 20px auto 0;
            padding: 15px;
            background: #f3f4f6;
            border-radius: 15px;
        }

        .team-score {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 10px;
            transition: transform 0.3s;
        }

        .team-score.winning {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
        }

        .team-score h2 {
            font-size: 1.8em;
            margin-bottom: 10px;
        }

        .score-number {
            font-size: 3em;
            font-weight: bold;
            color: var(--accent);
        }

        .round-info {
            text-align: center;
            font-size: 1.5em;
        }

        .round-number {
            font-size: 2em;
            font-weight: bold;
            color: var(--primary);
        }

        .main-content {
            flex: 1;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            padding: 30px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .game-area {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            grid-template-rows: repeat(var(--grid-size), 1fr);
            gap: 3px;
            aspect-ratio: 1;
            max-width: 600px;
            margin: 0 auto;
            background: #d1d5db;
            padding: 5px;
            border-radius: 10px;
        }

        .cell {
            background: white;
            border: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5em;
            position: relative;
            transition: all 0.3s;
        }

        .cell.player-class {
            background: var(--primary);
            animation: pulse 1s infinite;
        }

        .cell.player-ai {
            background: var(--secondary);
            animation: pulse 1s infinite;
        }

        .cell.treasure {
            background: gold;
            animation: sparkle 1s infinite;
        }

        .cell.hot {
            background: #fecaca;
        }

        .cell.warm {
            background: #fed7aa;
        }

        .cell.cold {
            background: #dbeafe;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes sparkle {
            0%, 100% { box-shadow: 0 0 10px gold; }
            50% { box-shadow: 0 0 30px gold; }
        }

        .ai-panel {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .ai-panel h2 {
            color: var(--secondary);
            margin-bottom: 20px;
            font-size: 2em;
        }

        .ai-status {
            padding: 15px;
            background: #f3f4f6;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .ai-status p {
            margin: 10px 0;
            font-size: 1.2em;
        }

        .ai-status strong {
            color: var(--accent);
        }

        .q-heatmap {
            width: 100%;
            border: 3px solid var(--secondary);
            border-radius: 10px;
            margin-top: 20px;
        }

        .voting-area {
            background: white;
            padding: 30px;
            margin: 0 30px 30px;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            text-align: center;
        }

        .voting-instruction {
            font-size: 2.5em;
            color: var(--primary);
            margin-bottom: 30px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .vote-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 800px;
            margin: 0 auto;
        }

        .vote-btn {
            padding: 30px;
            font-size: 3em;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .vote-btn:hover {
            transform: scale(1.1);
        }

        .vote-btn.selected {
            background: var(--accent);
            animation: pulse 0.5s;
        }

        .controls {
            padding: 20px;
            background: white;
            margin: 0 30px;
            border-radius: 20px;
            text-align: center;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 15px 30px;
            font-size: 1.3em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-success {
            background: var(--secondary);
            color: white;
        }

        .btn-warning {
            background: var(--accent);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 600px;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal h2 {
            font-size: 3em;
            margin-bottom: 20px;
        }

        .winner-class { color: var(--primary); }
        .winner-ai { color: var(--secondary); }

        .learning-graph {
            width: 100%;
            height: 200px;
            border: 2px solid var(--secondary);
            border-radius: 10px;
            margin-top: 20px;
        }

        .countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10em;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 50px rgba(0,0,0,0.5);
            z-index: 500;
            display: none;
        }

        .countdown.show {
            display: block;
            animation: countPulse 1s;
        }

        @keyframes countPulse {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .student-names {
            display: none;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .student-name {
            padding: 8px 15px;
            background: #f3f4f6;
            border-radius: 20px;
            font-size: 1.1em;
        }

        .student-name.voted {
            background: var(--accent);
            color: white;
        }

        .tips {
            background: #fef3c7;
            border-left: 4px solid var(--accent);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .tips h3 {
            color: var(--accent);
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ Schatzoeken: Klas vs AI ü§ñ</h1>
        <p style="font-size: 1.3em; color: #6b7280;">Leer hoe een computer leert door Reinforcement Learning!</p>
    </div>

    <div class="score-bar">
        <div class="team-score" id="class-score-card">
            <h2>üë• Klas</h2>
            <div class="score-number" id="class-wins">0</div>
            <div>gewonnen rondes</div>
        </div>
        
        <div class="round-info">
            <div>Ronde</div>
            <div class="round-number"><span id="current-round">1</span> / 10</div>
        </div>
        
        <div class="team-score" id="ai-score-card">
            <h2>ü§ñ AI</h2>
            <div class="score-number" id="ai-wins">0</div>
            <div>gewonnen rondes</div>
        </div>
    </div>

    <div class="main-content">
        <div class="game-area">
            <div id="game-grid" class="game-grid"></div>
            
            <div class="tips">
                <h3>üí° Tip:</h3>
                <p id="game-tip">De AI begint met willekeurige bewegingen, maar leert snel!</p>
            </div>
        </div>

        <div class="ai-panel">
            <h2>üß† AI Brein</h2>
            
            <div class="ai-status">
                <p><strong>Status:</strong> <span id="ai-status">Aan het leren...</span></p>
                <p><strong>Exploratie:</strong> <span id="exploration">100%</span></p>
                <p><strong>Laatste actie:</strong> <span id="last-action">Wacht...</span></p>
                <p><strong>Beloning:</strong> <span id="reward">0</span></p>
            </div>

            <h3>Q-Waardes Heatmap</h3>
            <canvas id="q-heatmap" class="q-heatmap" width="300" height="300"></canvas>
            
            <h3 style="margin-top: 20px;">Leervoortgang</h3>
            <canvas id="learning-graph" class="learning-graph"></canvas>
        </div>
    </div>

    <div class="voting-area" id="voting-area">
        <div class="voting-instruction">
            üó≥Ô∏è STEM NU! Welke kant op?
        </div>
        <div class="vote-options">
            <button class="vote-btn" data-dir="up">‚¨ÜÔ∏è</button>
            <button class="vote-btn" data-dir="down">‚¨áÔ∏è</button>
            <button class="vote-btn" data-dir="left">‚¨ÖÔ∏è</button>
            <button class="vote-btn" data-dir="right">‚û°Ô∏è</button>
        </div>
        <div class="student-names" id="student-names"></div>
    </div>

    <div class="controls">
        <button class="btn btn-primary" id="start-btn">üéÆ Start Nieuw Spel</button>
        <button class="btn btn-success" id="next-round-btn" disabled>‚û°Ô∏è Volgende Ronde</button>
        <button class="btn btn-warning" id="reset-ai-btn">üîÑ Reset AI Leren</button>
        <select id="ai-level" class="btn" style="background: #f3f4f6;">
            <option value="live">Live Leren</option>
            <option value="beginner">Pre-trained: Beginner</option>
            <option value="intermediate">Pre-trained: Gemiddeld</option>
            <option value="expert">Pre-trained: Expert</option>
        </select>
        <select id="grid-size" class="btn" style="background: #f3f4f6;">
            <option value="5">5x5 Grid</option>
            <option value="7" selected>7x7 Grid</option>
            <option value="9">9x9 Grid</option>
        </select>
    </div>

    <div class="modal" id="round-modal">
        <div class="modal-content">
            <h2 id="round-winner">üéâ Klas Wint!</h2>
            <p style="font-size: 1.5em; margin: 20px 0;" id="round-summary"></p>
            <button class="btn btn-primary" onclick="closeModal()">Sluiten</button>
        </div>
    </div>

    <div class="countdown" id="countdown"></div>

    <script>
        // Pre-trained Q-tables for different skill levels
        const preTrainedQTables = {
            beginner: {},
            intermediate: {},
            expert: {}
        };

        // Generate safe student names
        const adjectives = ['Blije', 'Slimme', 'Snelle', 'Dappere', 'Vrolijke', 'Sterke', 'Wijze', 'Coole'];
        const nouns = ['Banaan', 'Appel', 'Tijger', 'Dolfijn', 'Arend', 'Ster', 'Raket', 'Pizza'];
        
        function generateStudentName() {
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            return adj + noun;
        }

        // Game class
        class TreasureGame {
            constructor() {
                this.gridSize = 7;
                this.classPos = {x: 0, y: 0};
                this.aiPos = {x: 0, y: 0};
                this.treasurePos = {x: 0, y: 0};
                this.round = 1;
                this.classWins = 0;
                this.aiWins = 0;
                this.gameActive = false;
                this.currentTurn = 'class';
                
                this.qAgent = new QLearningAgent(this.gridSize);
                this.learningHistory = [];
                
                this.initElements();
                this.initEventListeners();
                this.initPretrainedNetworks();
                this.render();
            }
            
            initElements() {
                this.grid = document.getElementById('game-grid');
                this.startBtn = document.getElementById('start-btn');
                this.nextRoundBtn = document.getElementById('next-round-btn');
                this.resetAiBtn = document.getElementById('reset-ai-btn');
                this.aiLevelSelect = document.getElementById('ai-level');
                this.gridSizeSelect = document.getElementById('grid-size');
                
                this.classWinsEl = document.getElementById('class-wins');
                this.aiWinsEl = document.getElementById('ai-wins');
                this.currentRoundEl = document.getElementById('current-round');
                
                this.aiStatusEl = document.getElementById('ai-status');
                this.explorationEl = document.getElementById('exploration');
                this.lastActionEl = document.getElementById('last-action');
                this.rewardEl = document.getElementById('reward');
                
                this.qCanvas = document.getElementById('q-heatmap');
                this.qCtx = this.qCanvas.getContext('2d');
                this.graphCanvas = document.getElementById('learning-graph');
                this.graphCtx = this.graphCanvas.getContext('2d');
                
                this.voteButtons = document.querySelectorAll('.vote-btn');
                this.votingArea = document.getElementById('voting-area');
                this.gameTip = document.getElementById('game-tip');
            }
            
            initEventListeners() {
                this.startBtn.addEventListener('click', () => this.startNewGame());
                this.nextRoundBtn.addEventListener('click', () => this.nextRound());
                this.resetAiBtn.addEventListener('click', () => this.resetAI());
                
                this.aiLevelSelect.addEventListener('change', (e) => {
                    if (e.target.value !== 'live') {
                        this.loadPretrainedNetwork(e.target.value);
                    }
                });
                
                this.gridSizeSelect.addEventListener('change', (e) => {
                    this.gridSize = parseInt(e.target.value);
                    document.documentElement.style.setProperty('--grid-size', this.gridSize);
                    this.qAgent = new QLearningAgent(this.gridSize);
                    this.render();
                });
                
                // Keyboard controls for teacher
                document.addEventListener('keydown', (e) => {
                    if (!this.gameActive || this.currentTurn !== 'class') return;
                    
                    switch(e.key) {
                        case 'ArrowUp': this.makeClassMove('up'); break;
                        case 'ArrowDown': this.makeClassMove('down'); break;
                        case 'ArrowLeft': this.makeClassMove('left'); break;
                        case 'ArrowRight': this.makeClassMove('right'); break;
                    }
                });
                
                // Vote buttons for demonstration
                this.voteButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (this.currentTurn !== 'class') return;
                        const dir = btn.dataset.dir;
                        this.highlightVote(btn);
                        setTimeout(() => this.makeClassMove(dir), 500);
                    });
                });
            }
            
            initPretrainedNetworks() {
                // Generate pre-trained Q-tables by simulating training
                this.generatePretrainedNetwork('beginner', 100);
                this.generatePretrainedNetwork('intermediate', 500);
                this.generatePretrainedNetwork('expert', 1000);
            }
            
            generatePretrainedNetwork(level, episodes) {
                const agent = new QLearningAgent(this.gridSize);
                
                for (let ep = 0; ep < episodes; ep++) {
                    let state = '0,0';
                    const treasureX = Math.floor(Math.random() * this.gridSize);
                    const treasureY = Math.floor(Math.random() * this.gridSize);
                    
                    for (let step = 0; step < 50; step++) {
                        const action = agent.selectAction(state);
                        const [x, y] = state.split(',').map(Number);
                        let newX = x, newY = y;
                        
                        switch(action) {
                            case 0: newY = Math.max(0, y - 1); break;
                            case 1: newY = Math.min(this.gridSize - 1, y + 1); break;
                            case 2: newX = Math.max(0, x - 1); break;
                            case 3: newX = Math.min(this.gridSize - 1, x + 1); break;
                        }
                        
                        const oldDist = Math.abs(x - treasureX) + Math.abs(y - treasureY);
                        const newDist = Math.abs(newX - treasureX) + Math.abs(newY - treasureY);
                        let reward = (oldDist - newDist) * 10;
                        
                        if (newX === treasureX && newY === treasureY) {
                            reward = 100;
                        }
                        
                        const nextState = `${newX},${newY}`;
                        agent.update(state, action, reward, nextState);
                        
                        state = nextState;
                        if (newX === treasureX && newY === treasureY) break;
                    }
                    
                    agent.decayEpsilon();
                }
                
                preTrainedQTables[level] = { ...agent.qTable };
            }
            
            loadPretrainedNetwork(level) {
                this.qAgent.qTable = { ...preTrainedQTables[level] };
                this.qAgent.epsilon = 0.1; // Low exploration for pre-trained
                this.updateAIDisplay();
                this.aiStatusEl.textContent = `Pre-trained ${level} geladen`;
            }
            
            startNewGame() {
                this.round = 1;
                this.classWins = 0;
                this.aiWins = 0;
                this.learningHistory = [];
                this.currentRoundEl.textContent = '1';
                this.classWinsEl.textContent = '0';
                this.aiWinsEl.textContent = '0';
                
                if (this.aiLevelSelect.value === 'live') {
                    this.qAgent = new QLearningAgent(this.gridSize);
                }
                
                this.startRound();
            }
            
            startRound() {
                this.gameActive = true;
                this.currentTurn = 'ai';
                this.nextRoundBtn.disabled = true;
                
                // Reset positions
                this.classPos = {x: 0, y: 0};
                this.aiPos = {x: 0, y: 0};
                
                // Random treasure position
                do {
                    this.treasurePos = {
                        x: Math.floor(Math.random() * this.gridSize),
                        y: Math.floor(Math.random() * this.gridSize)
                    };
                } while (this.treasurePos.x === 0 && this.treasurePos.y === 0);
                
                this.render();
                this.updateTips();
                
                // Start with AI move
                setTimeout(() => this.makeAIMove(), 1000);
            }
            
            makeAIMove() {
                if (!this.gameActive) return;
                
                const state = `${this.aiPos.x},${this.aiPos.y}`;
                const action = this.qAgent.selectAction(state);
                
                const actions = ['Omhoog', 'Omlaag', 'Links', 'Rechts'];
                this.lastActionEl.textContent = actions[action];
                
                const oldPos = {...this.aiPos};
                
                switch(action) {
                    case 0: this.aiPos.y = Math.max(0, this.aiPos.y - 1); break;
                    case 1: this.aiPos.y = Math.min(this.gridSize - 1, this.aiPos.y + 1); break;
                    case 2: this.aiPos.x = Math.max(0, this.aiPos.x - 1); break;
                    case 3: this.aiPos.x = Math.min(this.gridSize - 1, this.aiPos.x + 1); break;
                }
                
                // Calculate reward
                const oldDist = this.getDistance(oldPos, this.treasurePos);
                const newDist = this.getDistance(this.aiPos, this.treasurePos);
                let reward = (oldDist - newDist) * 10;
                
                if (this.aiPos.x === this.treasurePos.x && this.aiPos.y === this.treasurePos.y) {
                    reward = 100;
                    this.endRound('ai');
                }
                
                this.rewardEl.textContent = reward > 0 ? `+${reward}` : reward;
                
                // Update Q-learning
                const nextState = `${this.aiPos.x},${this.aiPos.y}`;
                this.qAgent.update(state, action, reward, nextState);
                
                this.render();
                this.updateAIDisplay();
                
                if (this.gameActive) {
                    this.currentTurn = 'class';
                    this.showVotingPrompt();
                }
            }
            
            makeClassMove(direction) {
                if (!this.gameActive || this.currentTurn !== 'class') return;
                
                switch(direction) {
                    case 'up': this.classPos.y = Math.max(0, this.classPos.y - 1); break;
                    case 'down': this.classPos.y = Math.min(this.gridSize - 1, this.classPos.y + 1); break;
                    case 'left': this.classPos.x = Math.max(0, this.classPos.x - 1); break;
                    case 'right': this.classPos.x = Math.min(this.gridSize - 1, this.classPos.x + 1); break;
                }
                
                this.render();
                
                if (this.classPos.x === this.treasurePos.x && this.classPos.y === this.treasurePos.y) {
                    this.endRound('class');
                } else {
                    this.currentTurn = 'ai';
                    setTimeout(() => this.makeAIMove(), 1000);
                }
            }
            
            endRound(winner) {
                this.gameActive = false;
                
                if (winner === 'class') {
                    this.classWins++;
                    this.classWinsEl.textContent = this.classWins;
                    this.showRoundResult('üéâ Klas Wint!', 'winner-class');
                } else {
                    this.aiWins++;
                    this.aiWinsEl.textContent = this.aiWins;
                    this.showRoundResult('ü§ñ AI Wint!', 'winner-ai');
                }
                
                // Update learning history
                this.learningHistory.push({
                    round: this.round,
                    aiWins: this.aiWins,
                    classWins: this.classWins
                });
                this.drawLearningGraph();
                
                // Decay epsilon for next round
                this.qAgent.decayEpsilon();
                
                if (this.round < 10) {
                    this.nextRoundBtn.disabled = false;
                } else {
                    this.endGame();
                }
            }
            
            nextRound() {
                this.round++;
                this.currentRoundEl.textContent = this.round;
                this.startRound();
            }
            
            endGame() {
                const winner = this.classWins > this.aiWins ? 'Klas' : 'AI';
                const message = `Eindstand: Klas ${this.classWins} - ${this.aiWins} AI`;
                this.showRoundResult(`üèÜ ${winner} wint het spel!`, 
                    winner === 'Klas' ? 'winner-class' : 'winner-ai', message);
            }
            
            showRoundResult(title, className, message = '') {
                const modal = document.getElementById('round-modal');
                const titleEl = document.getElementById('round-winner');
                const summaryEl = document.getElementById('round-summary');
                
                titleEl.textContent = title;
                titleEl.className = className;
                summaryEl.textContent = message || `Ronde ${this.round} van 10 compleet`;
                
                modal.classList.add('show');
            }
            
            showVotingPrompt() {
                // Visual prompt for voting
                this.votingArea.style.background = '#fef3c7';
                setTimeout(() => {
                    this.votingArea.style.background = 'white';
                }, 500);
            }
            
            highlightVote(button) {
                this.voteButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
            }
            
            resetAI() {
                this.qAgent = new QLearningAgent(this.gridSize);
                this.learningHistory = [];
                this.updateAIDisplay();
                this.aiStatusEl.textContent = 'AI gereset - moet opnieuw leren!';
            }
            
            getDistance(pos1, pos2) {
                return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
            }
            
            render() {
                this.grid.innerHTML = '';
                
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        
                        // Distance-based coloring
                        const dist = this.getDistance({x, y}, this.treasurePos);
                        if (dist <= 1) cell.classList.add('hot');
                        else if (dist <= 2) cell.classList.add('warm');
                        else if (dist >= 4) cell.classList.add('cold');
                        
                        // Add entities
                        if (x === this.classPos.x && y === this.classPos.y) {
                            cell.classList.add('player-class');
                            cell.textContent = 'üòä';
                        }
                        if (x === this.aiPos.x && y === this.aiPos.y) {
                            cell.classList.add('player-ai');
                            cell.textContent = 'ü§ñ';
                        }
                        if (x === this.treasurePos.x && y === this.treasurePos.y) {
                            cell.classList.add('treasure');
                            cell.textContent = 'üíé';
                        }
                        
                        this.grid.appendChild(cell);
                    }
                }
                
                // Update score card highlights
                document.getElementById('class-score-card').classList.toggle('winning', this.classWins > this.aiWins);
                document.getElementById('ai-score-card').classList.toggle('winning', this.aiWins > this.classWins);
            }
            
            updateAIDisplay() {
                const epsilon = this.qAgent.epsilon;
                this.explorationEl.textContent = `${Math.round(epsilon * 100)}% verkennend, ${Math.round((1-epsilon) * 100)}% gebruikend`;
                this.aiStatusEl.textContent = epsilon > 0.5 ? 'Aan het verkennen...' : 'Gebruik geleerde kennis';
                
                this.drawQHeatmap();
            }
            
            drawQHeatmap() {
                const cellSize = 300 / this.gridSize;
                this.qCtx.clearRect(0, 0, 300, 300);
                
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const state = `${x},${y}`;
                        const qValues = this.qAgent.qTable[state] || [0, 0, 0, 0];
                        const maxQ = Math.max(...qValues);
                        
                        // Color based on Q-value
                        const intensity = Math.min(255, Math.abs(maxQ) * 2.5);
                        if (maxQ > 0) {
                            this.qCtx.fillStyle = `rgb(0, ${intensity}, 0)`;
                        } else if (maxQ < 0) {
                            this.qCtx.fillStyle = `rgb(${intensity}, 0, 0)`;
                        } else {
                            this.qCtx.fillStyle = 'rgb(200, 200, 200)';
                        }
                        
                        this.qCtx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
                        
                        // Mark treasure
                        if (x === this.treasurePos.x && y === this.treasurePos.y) {
                            this.qCtx.fillStyle = 'gold';
                            this.qCtx.beginPath();
                            this.qCtx.arc(
                                x * cellSize + cellSize/2,
                                y * cellSize + cellSize/2,
                                cellSize/3,
                                0, 2 * Math.PI
                            );
                            this.qCtx.fill();
                        }
                    }
                }
            }
            
            drawLearningGraph() {
                const ctx = this.graphCtx;
                const width = this.graphCanvas.width;
                const height = this.graphCanvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                if (this.learningHistory.length < 2) return;
                
                // Draw axes
                ctx.strokeStyle = '#e5e7eb';
                ctx.beginPath();
                ctx.moveTo(30, height - 30);
                ctx.lineTo(width - 10, height - 30);
                ctx.moveTo(30, 10);
                ctx.lineTo(30, height - 30);
                ctx.stroke();
                
                // Draw data
                const maxWins = 10;
                const xStep = (width - 40) / 10;
                const yScale = (height - 40) / maxWins;
                
                // AI wins line
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 3;
                ctx.beginPath();
                this.learningHistory.forEach((point, i) => {
                    const x = 30 + i * xStep;
                    const y = height - 30 - (point.aiWins * yScale);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                // Class wins line
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 3;
                ctx.beginPath();
                this.learningHistory.forEach((point, i) => {
                    const x = 30 + i * xStep;
                    const y = height - 30 - (point.classWins * yScale);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }
            
            updateTips() {
                const tips = [
                    "De AI begint met willekeurige bewegingen, maar leert snel!",
                    "Let op de Q-waardes heatmap - groen betekent goede posities!",
                    "De AI onthoud wat werkt en wat niet werkt.",
                    "Na een paar rondes wordt de AI steeds slimmer!",
                    "Reinforcement Learning = leren door beloningen!"
                ];
                
                if (this.round <= 3) {
                    this.gameTip.textContent = tips[0];
                } else if (this.round <= 6) {
                    this.gameTip.textContent = tips[2];
                } else {
                    this.gameTip.textContent = tips[3];
                }
            }
        }

        // Q-Learning Agent
        class QLearningAgent {
            constructor(gridSize) {
                this.gridSize = gridSize;
                this.qTable = {};
                this.alpha = 0.1;  // Learning rate
                this.gamma = 0.9;  // Discount factor
                this.epsilon = 1.0; // Exploration rate
                this.epsilonDecay = 0.9;
                this.minEpsilon = 0.1;
            }
            
            getQValues(state) {
                if (!this.qTable[state]) {
                    this.qTable[state] = [0, 0, 0, 0]; // up, down, left, right
                }
                return this.qTable[state];
            }
            
            selectAction(state) {
                if (Math.random() < this.epsilon) {
                    // Explore: random action
                    return Math.floor(Math.random() * 4);
                } else {
                    // Exploit: best known action
                    const qValues = this.getQValues(state);
                    const maxQ = Math.max(...qValues);
                    const bestActions = [];
                    qValues.forEach((q, i) => {
                        if (q === maxQ) bestActions.push(i);
                    });
                    return bestActions[Math.floor(Math.random() * bestActions.length)];
                }
            }
            
            update(state, action, reward, nextState) {
                const qValues = this.getQValues(state);
                const nextQValues = this.getQValues(nextState);
                const maxNextQ = Math.max(...nextQValues);
                
                // Q-learning update rule
                qValues[action] = qValues[action] + this.alpha * (reward + this.gamma * maxNextQ - qValues[action]);
                
                this.qTable[state] = qValues;
            }
            
            decayEpsilon() {
                this.epsilon = Math.max(this.minEpsilon, this.epsilon * this.epsilonDecay);
            }
        }

        // Helper functions
        function closeModal() {
            document.getElementById('round-modal').classList.remove('show');
        }

        // Initialize game on load
        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new TreasureGame();
        });
    </script>
</body>
</html>